# Here we will define all functions that hold visuals that will be used into our project

import streamlit as st
from src.utils import get_data, config_file, generate_report, send_email_with_attachment
from pyhocon import ConfigFactory
import plotly.express as px
from fpdf import FPDF
import pandas as pd
from datetime import datetime
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import tempfile
from visualizations.charts import *
import pandas as pd
from streamlit_lottie import st_lottie
import requests
from src.utils import generate_csv_report, generate_pdf_report

config = ConfigFactory.parse_file(config_file)
server = config.db_dwh.server
database = config.db_dwh.database
username = config.db_dwh.username
password = config.db_dwh.password
schema_table = config.db_dwh.schema_table
sql_data = config.sql_path.sql_data


st.set_page_config(page_title='Sales WEB APP', page_icon="üìä", layout="wide", initial_sidebar_state="expanded")
# Grab data from our table
@st.cache_data
def getting_data() -> pd.DataFrame:
    df_base = get_data(server, database, username, password, sql_data)
    
    return df_base

df_base = getting_data()

def load_lottie_url(url: str):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()


def show_home():
    # Header
    st.title("üìä Logging System Dashboard")

    col1, col2 = st.columns([2, 1])
    with col1:
        # Introduction Section
        st.markdown("""
        ## Welcome to the Logging System Dashboard! üëã
        
        This dashboard provides an overview of the log data generated by our system. Here, you'll be able to monitor log entries, analyze trends, and gain insights into system performance and issues.
        
        ### What You'll Find Here:
        
        - **üìà Log Entries Overview**: Understand the volume and types of log entries over time.
        - **üìä Error Trends and Analysis**: Identify patterns and trends in error logs.
        - **üí° System Performance Insights**: Gain insights into system performance based on log data.
        """)

        # Key Columns Description
        st.markdown("## Key Log Data Columns")
        st.markdown("""
        - **date**: The timestamp when the log entry was recorded.
        - **levelname**: The severity level of the log entry (e.g., INFO, WARNING, ERROR).
        - **message**: The log message providing details about the event or issue.
        - **project_name**: The name of the project or application generating the log entry.
        - **status**: The status associated with the log entry (e.g., SUCCESS, FAILURE).
        - **duration**: The duration of the event or process being logged.
        - **load_file**: The timestamp when the log file was loaded into the system.
        """)

        # Explanation Section
        st.markdown("""
    ## Why This Matters üöÄ
    Understanding the log data helps us:
    - **Identify and Resolve Issues**: Quickly identify system errors and warnings to resolve issues promptly.
    - **Monitor System Health**: Keep track of the system's health and performance over time.
    - **Improve System Reliability**: Use log data insights to enhance the reliability and stability of the system.
    """)

    with col2:
        lottie_url = "https://lottie.host/b24673c0-3cd7-4b3d-8648-b35d14195e51/QZ2KPAP5Nx.json"  # Replace with your chosen Lottie animation URL
        lottie_json = load_lottie_url(lottie_url)
        if lottie_json:
            st_lottie(lottie_json, height=400, width=450, key="logging_animation")
    # Next Steps
    st.markdown("""
    ## Next Steps üìÖ
    Explore the dashboard to gain deeper insights into our log data. Use the information to monitor system performance, identify issues, and improve reliability. If you have any questions or need further analysis, feel free to reach out to the IT team.
    
    ### Thank you for using the Logging System Dashboard! üôè
    """)

def show_analytics():
    st.title("Logging System Dashboard")
    st.write("Welcome to the Logging System Dashboard. Here, you can find insights into the logging system's performance across different entities.")
    df_base['date'] = pd.to_datetime(df_base['date'])
    df_base['duration'] = df_base['duration'].astype(float)
    
    # Filters
    project_names = st.multiselect("Filter by Project Name", options=df_base["project_name"].unique(), default=df_base["project_name"].unique())
    dates = st.date_input("Filter by Date", value=[df_base["date"].min(), df_base["date"].max()])
    statuses = st.multiselect("Filter by Status", options=df_base["status"].unique(), default=df_base["status"].unique())
    
    # Apply filters
    filtered_df = df_base[
        (df_base["project_name"].isin(project_names)) &
        (df_base["date"].between(pd.to_datetime(dates[0]), pd.to_datetime(dates[1]))) &
        (df_base["status"].isin(statuses))
    ]
    
    # KPI calculations
    total_jobs = len(filtered_df)
    success_percentage = (len(filtered_df[filtered_df["status"] == "success"]) / total_jobs) * 100 if total_jobs > 0 else 0
    
    # Display KPIs
    st.header("Key Performance Indicators (KPIs)")
    st.metric(label="Number of Jobs", value=total_jobs)
    st.metric(label="Percentage of Success Logs", value=f"{success_percentage:.2f}%")
    
    # Status by Project and Date
    st.subheader("Status by Project")
    fig0 =  generate_bar_chart_count(filtered_df, 'project_name', 'status', 'message', 
                               'Proportion of Success and Failure by Project', 
                               'bar', head=None)
    st.plotly_chart(fig0)
    
    

    st.subheader("Duration by Project")
    fig1 = generate_simple_bar_chart(filtered_df, 'project_name', 'duration', 'Duration by Project', 'bar')
    st.plotly_chart(fig1)
    
   
    st.subheader("Log Level Distribution")
    colors = ['royalblue', 'red']
    fig3 = generate_pie_chart(filtered_df, 'levelname', 'duration', 'Log Level Distribution', colors)
    st.plotly_chart(fig3)
    
    with st.expander("Data Overview"):
        st.dataframe(filtered_df)
   
   
    
    
def show_reports():
    st.title("Project Reports")
    st.write("Generate and download detailed project reports.")

    st.header("Data Overview")
    with st.expander("Data Overview"):
        st.dataframe(df_base)

    st.header("Filter and Download Reports")
    df_base['date_only'] = df_base['date'].dt.date
    # Filtre de s√©lection de date
    selected_date = st.date_input("Pick a date", pd.to_datetime("today"))
    filtered_df = df_base[df_base['date_only'] == selected_date]

    st.write(f"Data for {selected_date}")
    st.dataframe(filtered_df)

    generate_csv_report(filtered_df)
    generate_pdf_report(filtered_df)
    
    
def show_contacts():
    st.title("Contact Us")
    st.write("Please fill out the form below to reach out to us for new requests, report bugs, or provide feedback.")

    # Form
    with st.form(key='contact_form'):
        name = st.text_input("Name")
        role = st.text_input("Role")
        needs = st.text_area("Needs / Feedback")
        email = st.text_input("Email")
        
        submit_button = st.form_submit_button(label='Submit')

    # Form submission handling
    if submit_button:
        if name and role and needs and email:
            st.success("Thank you for your submission! We will get back to you soon.")
            # Here you can handle the form submission, e.g., save the data to a database, send an email, etc.
            # For demonstration, we'll just print the form data
            form_data = {
                "Name": name,
                "Role": role,
                "Needs": needs,
                "Email": email
            }
            form_data_str = '\n'.join([f"{key}: {value}" for key, value in form_data.items()])
            
            send_email_with_attachment(subject="New request for DCX", body=form_data_str, recipient_list=config.email.recipient_list)
        else:
            st.error("Please fill in all the required fields.")
    