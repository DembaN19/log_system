# Here we will define all functions that hold visuals that will be used into our project

import streamlit as st
from src.utils import get_data, config_file, generate_report, send_email_with_attachment
from pyhocon import ConfigFactory
import plotly.express as px
from fpdf import FPDF
import pandas as pd
from datetime import datetime
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import tempfile
from visualizations.charts import *
import pandas as pd
from streamlit_lottie import st_lottie
import requests


config = ConfigFactory.parse_file(config_file)
server = config.db_dwh.server
database = config.db_dwh.database
username = config.db_dwh.username
password = config.db_dwh.password
schema_table = config.db_dwh.schema_table
sql_data = config.sql_path.sql_data


st.set_page_config(page_title='Sales WEB APP', page_icon="📊", layout="wide", initial_sidebar_state="expanded")
# Grab data from our table
@st.cache_data
def getting_data() -> pd.DataFrame:
    df_base = get_data(server, database, username, password, sql_data)
    
    return df_base

df_base = getting_data()

def load_lottie_url(url: str):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()


def show_home():
    # Header
    st.title("📊 Logging System Dashboard")

    col1, col2 = st.columns([2, 1])
    with col1:
        # Introduction Section
        st.markdown("""
        ## Welcome to the Logging System Dashboard! 👋
        
        This dashboard provides an overview of the log data generated by our system. Here, you'll be able to monitor log entries, analyze trends, and gain insights into system performance and issues.
        
        ### What You'll Find Here:
        
        - **📈 Log Entries Overview**: Understand the volume and types of log entries over time.
        - **📊 Error Trends and Analysis**: Identify patterns and trends in error logs.
        - **💡 System Performance Insights**: Gain insights into system performance based on log data.
        """)

        # Key Columns Description
        st.markdown("## Key Log Data Columns")
        st.markdown("""
        - **date**: The timestamp when the log entry was recorded.
        - **levelname**: The severity level of the log entry (e.g., INFO, WARNING, ERROR).
        - **message**: The log message providing details about the event or issue.
        - **project_name**: The name of the project or application generating the log entry.
        - **status**: The status associated with the log entry (e.g., SUCCESS, FAILURE).
        - **duration**: The duration of the event or process being logged.
        - **load_file**: The timestamp when the log file was loaded into the system.
        """)

        # Explanation Section
        st.markdown("""
    ## Why This Matters 🚀
    Understanding the log data helps us:
    - **Identify and Resolve Issues**: Quickly identify system errors and warnings to resolve issues promptly.
    - **Monitor System Health**: Keep track of the system's health and performance over time.
    - **Improve System Reliability**: Use log data insights to enhance the reliability and stability of the system.
    """)

    with col2:
        lottie_url = "https://lottie.host/b24673c0-3cd7-4b3d-8648-b35d14195e51/QZ2KPAP5Nx.json"  # Replace with your chosen Lottie animation URL
        lottie_json = load_lottie_url(lottie_url)
        if lottie_json:
            st_lottie(lottie_json, height=400, width=450, key="logging_animation")
    # Next Steps
    st.markdown("""
    ## Next Steps 📅
    Explore the dashboard to gain deeper insights into our log data. Use the information to monitor system performance, identify issues, and improve reliability. If you have any questions or need further analysis, feel free to reach out to the IT team.
    
    ### Thank you for using the Logging System Dashboard! 🙏
    """)

def show_analytics():
    st.title("Logging System Dashboard")
    st.write("Welcome to the Logging System Dashboard. Here, you can find insights into the logging system's performance across different entities.")
    df_base['date'] = pd.to_datetime(df_base['date'])
    
    # Filters
    project_names = st.multiselect("Filter by Project Name", options=df_base["project_name"].unique(), default=df_base["project_name"].unique())
    dates = st.date_input("Filter by Date", value=[df_base["date"].min(), df_base["date"].max()])
    statuses = st.multiselect("Filter by Status", options=df_base["status"].unique(), default=df_base["status"].unique())
    
    # Apply filters
    filtered_df = df_base[
        (df_base["project_name"].isin(project_names)) &
        (df_base["date"].between(pd.to_datetime(dates[0]), pd.to_datetime(dates[1]))) &
        (df_base["status"].isin(statuses))
    ]
    
    # KPI calculations
    total_jobs = len(filtered_df)
    success_percentage = (len(filtered_df[filtered_df["status"] == "success"]) / total_jobs) * 100 if total_jobs > 0 else 0
    
    # Display KPIs
    st.header("Key Performance Indicators (KPIs)")
    st.metric(label="Number of Jobs", value=total_jobs)
    st.metric(label="Percentage of Success Logs", value=f"{success_percentage:.2f}%")
    
    # Status by Project and Date
    st.subheader("Status by Project and Date")
    fig0 = generate_simple_bar_chart(filtered_df, 'project_name', 'status', 'Status by Project', 'bar')
    st.plotly_chart(fig0)
    
    

    st.subheader("Duration by Project")
    fig1 = generate_simple_bar_chart(filtered_df, 'project_name', 'duration', 'Duration by Project', 'bar')
    st.plotly_chart(fig1)
    
    
    st.subheader("Status by Project")
    fig2 = generate_bar_chart(filtered_df, 'project_name', 'status', 'duration', 'Status by Project', 'bar')
    st.plotly_chart(fig2)
    
   
    st.subheader("Log Level Distribution")
    fig3 = generate_pie_chart(filtered_df, 'levelname', 'duration', 'Log Level Distribution', px.colors.sequential.RdBu)
    st.plotly_chart(fig3)
    
   
   
   
    
    
def show_reports():
    
    st.title("Sales Reports")
    st.write("Generate and download detailed sales reports.")

    st.header("Sales Data Overview")
    with st.expander("Data Overview"):
        st.dataframe(df_base)

    st.header("Download Reports")
    generate_report(df_base)



    # PDF Report
    # Generate the pivot table
    pivot_table = df_base.pivot_table(
        index=['entity', 'ods', 'yeargl'],
        values='amount',
        aggfunc='sum'
    ).reset_index()

    # Calculate the percentage of digital sales regarding the CA
    pivot_table['Percentage'] = (pivot_table['Sales'] / df_base.groupby(['Entity', 'BusinessLine', 'YearGL'])['CA'].first().values) * 100

    pivot_table['Sales'] = pivot_table['Sales'].round(2)
    pivot_table['Percentage'] = pivot_table['Percentage'].round(2)
    # Streamlit button for generating PDF report
    if st.button("Generate PDF Report"):
        
        # Create a plot of the pivot table
        fig, ax = plt.subplots()
        ax.axis('tight')
        ax.axis('off')
        ax.table(cellText=pivot_table.values, colLabels=pivot_table.columns, cellLoc='center', loc='center')

        # Save the plot as a PNG file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.png') as tmpfile:
            plt.savefig(tmpfile.name, format='png')
            plt.close(fig)
            image_path = tmpfile.name

        # Generate PDF report
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=14)

        pdf.cell(200, 30, txt="DCX Sales Report", ln=True, align='C')
        pdf.ln(20)

        # Add the pivot table image to the PDF
        pdf.image(image_path, x=20, y=40, w=180)  # Adjust the position and size as needed

        pdf_output = pdf.output(dest='S').encode('latin1')

        

        st.download_button(
            label="Download PDF Report",
            data=pdf_output,
            file_name='sales_report.pdf',
            mime='application/pdf',
        )
    
def show_contacts():
    st.title("Contact Us")
    st.write("Please fill out the form below to reach out to us for new requests, report bugs, or provide feedback.")

    # Form
    with st.form(key='contact_form'):
        name = st.text_input("Name")
        role = st.text_input("Role")
        needs = st.text_area("Needs / Feedback")
        email = st.text_input("Email")
        
        submit_button = st.form_submit_button(label='Submit')

    # Form submission handling
    if submit_button:
        if name and role and needs and email:
            st.success("Thank you for your submission! We will get back to you soon.")
            # Here you can handle the form submission, e.g., save the data to a database, send an email, etc.
            # For demonstration, we'll just print the form data
            form_data = {
                "Name": name,
                "Role": role,
                "Needs": needs,
                "Email": email
            }
            form_data_str = '\n'.join([f"{key}: {value}" for key, value in form_data.items()])
            
            send_email_with_attachment(subject="New request for DCX", body=form_data_str, recipient_list=config.email.recipient_list)
        else:
            st.error("Please fill in all the required fields.")
    